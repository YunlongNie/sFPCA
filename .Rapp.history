x1 = rnorm(5)#
x2 = rnorm(5)#
x3 = rnorm(5)#
beta1 = 1#
beta2 = 1#
beta0 = 0#
#
y = beta0 + beta1*x1+beta2*x2  + rnorm(5)#
library(dplyr)#
#
mean(lm(y~x1+x2)%>%fitted - (beta0 + beta1*x1+beta2*x2))^2#
#
mean(lm(y~x1+x2+x3)%>%fitted - (beta0 + beta1*x1+beta2*x2))^2
beta0 + beta1*x1+beta2*x2
x1 = rnorm(2)#
x2 = rnorm(2)#
x3 = rnorm(2)#
beta1 = 1#
beta2 = 1#
beta0 = 0#
#
y = beta0 + beta1*x1+beta2*x2  + rnorm(5)#
library(dplyr)#
#
mean(lm(y~x1+x2)%>%fitted - (beta0 + beta1*x1+beta2*x2))^2#
#
mean(lm(y~x1+x2+x3)%>%fitted - (beta0 + beta1*x1+beta2*x2))^2
x1 = rnorm(2)#
x2 = rnorm(2)#
x3 = rnorm(2)#
beta1 = .1#
beta2 = .1#
beta0 = 0#
#
y = beta0 + beta1*x1+beta2*x2  + rnorm(5)#
library(dplyr)#
#
mean(lm(y~x1+x2)%>%fitted - (beta0 + beta1*x1+beta2*x2))^2#
#
mean(lm(y~x1+x2+x3)%>%fitted - (beta0 + beta1*x1+beta2*x2))^2
x1 = rnorm(5)#
x2 = rnorm(5)#
x3 = rnorm(5)#
beta1 = .1#
beta2 = .1#
beta0 = 0#
#
y = beta0 + beta1*x1+beta2*x2  + rnorm(5)#
library(dplyr)#
#
mean(lm(y~x1+x2)%>%fitted - (beta0 + beta1*x1+beta2*x2))^2#
#
mean(lm(y~x1+x2+x3)%>%fitted - (beta0 + beta1*x1+beta2*x2))^2
mtcars
b<-regsubsets(mpg~.,data=swiss)
library(leaps)
install.packages('leaps')
library(leaps)
b<-regsubsets(mpg~.,data=swiss)
b<-regsubsets(mpg~.,data=mtcars)
summary(b)
summ = summary(b)
summ$outmat
summ$bic
allsubsets<-regsubsets(mpg~.,data=mtcars)
summary(allsubsets)
summ_res = summary(allsubsets)
summ_res$which
summ_res$rsq
summ_res$bic
summ_res$obj
summ_res$which
matwhich = summ_res$which
rowSums(matwhich[,-1])
colnames(matwhich[,-1])
colnames(matwhich)[matwhich[i,]]
i=1
colnames(matwhich)[matwhich[i,]]
colnames(matwhich)[matwhich[i,]][-1]
(formula = as.formula(sprintf("mpg~%s",xvar)))
xvar = colnames(matwhich)[matwhich[i,]][-1]
(formula = as.formula(sprintf("mpg~%s",xvar)))
lm(formula,data=mtcars)
lm(formula,data=mtcars)%>%extractAIC
lm(formula,data=mtcars)%>%extractAIC[,2]
AIC = lm(formula,data=mtcars)%>%extractAIC
AIC
AIC = c()#
for (i in 1:8){#
xvar = colnames(matwhich)[matwhich[i,]][-1]#
(formula = as.formula(sprintf("mpg~%s",xvar)))#
print(formula)#
temp = lm(formula,data=mtcars)%>%extractAIC#
AIC[i] = temp[2]#
#
}
i=2
colnames(matwhich)[matwhich[i,]
colnames(matwhich)[matwhich[i,]]
xvar = colnames(matwhich)[matwhich[i,]][-1]
xvar = paste0(colnames(matwhich)[matwhich[i,]][-1],collapse="~")
xvar
xvar = paste0(colnames(matwhich)[matwhich[i,]][-1],collapse="+")
xvar
AIC = c()#
for (i in 1:8){#
xvar = paste0(colnames(matwhich)[matwhich[i,]][-1],collapse="+")#
#
(formula = as.formula(sprintf("mpg~%s",xvar)))#
print(formula)#
temp = lm(formula,data=mtcars)%>%extractAIC#
AIC[i] = temp[2]#
#
}
AIC
for (i in 1:8){#
xvar = paste0(colnames(matwhich)[matwhich[i,]][-1],collapse="+")#
(formula = as.formula(sprintf("mpg~%s",xvar)))#
print(formula)#
temp = lm(formula,data=mtcars)%>%extractAIC#
AIC[i] = temp[2]#
print(AIC[i])#
}
cat("AIC:" AIC[i]),"\n")
matwhich = summ_res$which#
rowSums(matwhich[,-1])#
AIC = c()#
for (i in 1:8){#
xvar = paste0(colnames(matwhich)[matwhich[i,]][-1],collapse="+")#
(formula = as.formula(sprintf("mpg~%s",xvar)))#
print(formula)#
temp = lm(formula,data=mtcars)%>%extractAIC#
AIC[i] = temp[2]#
cat("AIC:" AIC[i]),"\n")#
}
matwhich = summ_res$which#
rowSums(matwhich[,-1])#
AIC = c()#
for (i in 1:8){#
xvar = paste0(colnames(matwhich)[matwhich[i,]][-1],collapse="+")#
(formula = as.formula(sprintf("mpg~%s",xvar)))#
print(formula)#
temp = lm(formula,data=mtcars)%>%extractAIC#
AIC[i] = temp[2]#
cat("AIC:",AIC[i]),"\n")#
}
matwhich = summ_res$which#
rowSums(matwhich[,-1])#
AIC = c()#
for (i in 1:8){#
xvar = paste0(colnames(matwhich)[matwhich[i,]][-1],collapse="+")#
(formula = as.formula(sprintf("mpg~%s",xvar)))#
print(formula)#
temp = lm(formula,data=mtcars)%>%extractAIC#
AIC[i] = temp[2]#
cat("AIC:",AIC[i],"\n")#
}
for (i in 1:8){#
xvar = paste0(colnames(matwhich)[matwhich[i,]][-1],collapse="+")#
(formula = as.formula(sprintf("mpg~%s",xvar)))#
print(formula)#
temp = lm(formula,data=mtcars)%>%extractAIC#
AIC[i] = temp[2]#
cat("AIC:",AIC[i],"\n")#
temp = lm(formula,data=mtcars)%>%extractAIC(.,k=log(nrow(mtcars)))#
BIC[i] = temp[2]#
cat("BIC:",BIC[i],"\n")#
}
matwhich = summ_res$which#
rowSums(matwhich[,-1])#
AIC = c()#
BIC = c()#
for (i in 1:8){#
xvar = paste0(colnames(matwhich)[matwhich[i,]][-1],collapse="+")#
(formula = as.formula(sprintf("mpg~%s",xvar)))#
print(formula)#
temp = lm(formula,data=mtcars)%>%extractAIC#
AIC[i] = temp[2]#
cat("AIC:",AIC[i],"\n")#
temp = lm(formula,data=mtcars)%>%extractAIC(.,k=log(nrow(mtcars)))#
BIC[i] = temp[2]#
cat("BIC:",BIC[i],"\n")#
}
which.min(AIC)
which.min(BIC)
y = rnorm(10)#
xmat = matrix(NA,ncol=10,ncol=10)#
for (i in 1:10){#
	xmat[,i] = rnorm(10)#
}
y = rnorm(10)#
xmat = matrix(NA,ncol=10,nrow=10)#
for (i in 1:10){#
	xmat[,i] = rnorm(10)#
}
lm(y~xmat)
y = rnorm(10)#
xmat = matrix(NA,ncol=9,nrow=10)#
for (i in 1:9){#
	xmat[,i] = rnorm(10)#
}#
#
lm(y~xmat)
lm(y~xmat)%>%redisuals
lm(y~xmat)%>%resid
y = rnorm(10)#
xmat = matrix(NA,ncol=9,nrow=10)#
for (i in 1:9){#
	xmat[,i] = rnorm(10)#
}#
#
lm(y~xmat)#
#
lm(y~xmat)%>%resid
mean((ynew - lm(y~xmat)%>%resid)^2)
ynew  = rnorm(10)#
#
mean((ynew - lm(y~xmat)%>%resid)^2)
mean((ynew - lm(y~xmat)%>%fitted)^2)#
#
plot(ynew,lm(y~xmat)%>%fitted)
y = rnorm(10)#
xmat = matrix(NA,ncol=8,nrow=10)#
for (i in 1:8){#
	xmat[,i] = rnorm(10)#
}#
#
lm(y~xmat)#
#
lm(y~xmat)%>%resid#
ynew  = rnorm(10)#
#
mean((ynew - lm(y~xmat)%>%fitted)^2)#
#
plot(ynew,lm(y~xmat)%>%fitted)
lm(y~xmat)%>%resid
y
y = rnorm(10)#
xmat = matrix(NA,ncol=9,nrow=10)#
for (i in 1:9){#
	xmat[,i] = rnorm(10)#
}#
#
lm(y~xmat)#
#
lm(y~xmat)%>%resid
set.seed(392039853)#
#
reps <- 200 # Number of data sets#
N <- 20      # Sample size#
#
# Create test data#
test <- expand.grid(x1 = c(.1,.3,.5,.7,.9), x2 = c(.1,.3,.5,.7,.9), x3=c(.1,.3,.5,.7,.9))#
#
# Create vector of true means#
mu <- test$x1 + test$x2#
#
# Prepare for looping over reps#
counter <- 1#
# Matrix to save predictions: rows are replicates, #
#   columns are different X combinations times 3 (one for each model)#
save.pred <- matrix(data=NA, ncol=3*nrow(test), nrow=reps)#
# Matrix to save estimates of sigma^2#
#   Rows are replicates, columns are different models #
save.sig <- matrix(data=NA, ncol=3, nrow=reps)#
#
# Loop to generate data, analyze, and save results#
for(counter in c(1:reps)){#
# Generating Uniform X's and Normal errors#
  x1 <- runif(n=N)#
  x2 <- runif(n=N)#
  x3 <- runif(n=N)#
  ep <- rnorm(n=N)#
# Setting beta1=1, beta2=1, beta3=0#
  y <- 1*x1 + 1*x2 + ep#
#
# reg* is model-fit object, sig* is MSE, pred* is list of predicted values over grid #
  reg1 <- lm(y~x1)#
  sig1 <- sum(resid(reg1)^2) / reg1$df.residual#
# Could have used summary(reg1)$sigma^2#
  pred1 <- predict(reg1,newdata=test)#
#
  reg2 <- lm(y~x1 + x2)#
  sig2 <- sum(resid(reg2)^2) / reg2$df.residual#
  pred2 <- predict(reg2,newdata=test)#
#
  reg3 <- lm(y~x1 + x2 + x3)#
  sig3 <- sum(resid(reg3)^2) / reg3$df.residual#
  pred3 <- predict(reg3,newdata=test)#
#
# Saving all results into storage objects and incrementing row counter#
  save.pred[counter,] <- c(pred1, pred2, pred3)#
  save.sig[counter,] <- c(sig1,sig2,sig3)#
  counter <- counter + 1#
}#
#
# Estimate bias, variance, and MSE of predictions at each X-combo#
mean.pred <- apply(save.pred, MARGIN=2, FUN=mean)#
bias <- mean.pred - rep(mu, times=3)#
var <- apply(save.pred, MARGIN=2, FUN=var)#
MSE <- bias^2 + var#
#
# Vector of model numbers#
model <- rep(c(1,2,3), each=nrow(test))#
#
# Plots#
# win.graph(height=5, width=5, pointsize=15)#
quartz()#
stripchart(bias ~ model, method="jitter", jitter=.1, vertical=TRUE, pch=20)#
abline(h=0, lty="solid")#
#
# win.graph(height=5, width=5, pointsize=15)#
quartz()#
stripchart(var ~ model, method="jitter", jitter=.1, vertical=TRUE, pch=20)#
#
# win.graph(height=5, width=5, pointsize=15)#
quartz()#
stripchart(MSE ~ model, method="jitter", jitter=.1, vertical=TRUE, pch=20)
library(datasets)
data(mtcars)
model0 =  lm(mpg~1, mtcars)
summary(model0)
modelfull = lm(mpg~.,mtcars)
summary(modelfull)
step(model0,direction="forward")
step(model0,scope=list(lower=model0,upper=modelfull),direction="forward")%>%summary
summary(step(model0,scope=list(lower=model0,upper=modelfull),direction="forward"))
23.52^2*(t(as.matrix(c(1,77,8)))%*%matrix(solve(t(xmat)%*%xmat)%>%format(.,scientific=TRUE,digits=2)%>%as.numeric,3,3)%*%as.matrix(c(1,77,8)))
quartz()
library(sFPCA)
sfpca
?load('/Users/joha/Dropbox/Yunlong/Research_ideas/supervisored_FPCA/medfly/application1/medfly.Rdata')
load('/Users/joha/Dropbox/Yunlong/Research_ideas/supervisored_FPCA/medfly/application1/medfly.Rdata')
xmat = medfly$eggcount
y = medfly$lifetime
res = sfpca(xmat,y,0.1,1e3,npc_select=5)
plot(res$beta_fd)
plot(res$beta_fd,ylab="")
plot(res$beta_fd,ylab="beta(t)")
??sfpcs_binary
library(sFPCA)#
#
# a continuous response case #
data(medfly)#
xmat = medfly$eggcount  # 26 days and 50 flies #
y = medfly$lifetime#
res = sfpca(xmat,y,0.1,1e3,npc_select=5)#
plot(res$beta_fd,ylab="beta(t)")#
res$fitted #
res$sfpcs
library(fda)
CanadianWeather
?Canadian
?CanadianWeather
CanadianWeather$dailyAv
str(CanadianWeather$dailyAv)
names(CanadianWeather)
CanadianWeather$coordinates
CanadianWeather$place
library(sFPCA)
data(medfly)
xmat = medfly$eggcount  # 26 days and 50 flies
y = medfly$lifetime
theta=0.1
lambda=1e3
npc_select = 3
xmat_new = xmat
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix =xmat;rowM = rowMeans(train_matrix);train_matrix =sweep(train_matrix,1,rowM)#
train_y = y; meany = mean(train_y);train_y = (train_y-meany)#
if (is.null(timepts)) timepts=1:nrow(xmat)#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=range(timepts),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd, 1e2)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)
timepts = 1:26
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix =xmat;rowM = rowMeans(train_matrix);train_matrix =sweep(train_matrix,1,rowM)#
train_y = y; meany = mean(train_y);train_y = (train_y-meany)#
if (is.null(timepts)) timepts=1:nrow(xmat)#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=range(timepts),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd, 1e2)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)
if(!is.null(xmat_new)) #
	{#
		test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
		test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
#
	}
W = inprod(spline.basis,spline.basis)#
S = train.fd$coef #
maty = matrix(rep(train_y,each=nrow(S)),nrow=nrow(S))#
M = rowSums(maty*W%*%S)#
MM = as.matrix(M)%*%t(as.matrix(M))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}#
#
fpca = function(theta,lambda,npc)#
{#
#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
#
halfG_inv  = sqrM(G)#
#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
	})#
list(har = fd_list,varprp = varprp)#
}
scores= function(theta,lambda,npc)#
{#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM#
#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
#
halfG_inv  = sqrM(G)#
#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
#
temp_score = lapply(1:npc,function(ipc)#
{#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
train_score = inprod(fd,train.fd)#
as.numeric(train_score)#
	})#
#
traind = do.call(cbind.data.frame,temp_score)#
#
names(traind) = paste0("score",1:npc)#
#
traind$theta=theta;traind$y=train_y;traind$lambda=lambda#
traind#
}#
fpca_res = fpca(theta,lambda,npc=npc_select)
fpca_res
scores_res_train = scores(theta,lambda,npc=npc_select)
scores_res_train2 = lapply(fpcs_res$har,function(x) inprod(x,train.fd))
fpca_res = fpca(theta,lambda,npc=npc_select)
scores_res_train = lapply(fpcs_res$har,function(x) inprod(x,train.fd))
scores_res_train2 = lapply(fpcs_res$har,function(x) inprod(x,train.fd))
scores_res_train2 = lapply(fpca_res$har,function(x) inprod(x,train.fd))
scores_res_train2
head(scores_res_train)
scores_res_train = cbindlist(lapply(fpca_res$har,function(x) inprod(x,train.fd)))
??cbindlist
?rbind_list
scores_res_train = cbind_list(lapply(fpca_res$har,function(x) inprod(x,train.fd)))
scores_res_train = dplyr::cbind_list(lapply(fpca_res$har,function(x) inprod(x,train.fd)))
cbind2
?cbind2
/rbind_list
?rbind_list
bind_colsscores_res_train = bind_cols(lapply(fpca_res$har,function(x) inprod(x,train.fd)))
scores_res_train = bind_cols(lapply(fpca_res$har,function(x) inprod(x,train.fd)))
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) inprod(x,train.fd))))
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) inprod(x,train.fd)))
scores_res_train
lapply(fpca_res$har,function(x) inprod(x,train.fd))
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))
scores_res_train
names(scores_res_train) = paste0("score",1:npc)
npc_select
names(scores_res_train) = paste0("score",1:npc_select)
npc_select
scores_res_train
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y
scores_res_train
if (!is.null(xmat_new))#
{#
scores_res_new = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,test.fd))))#
names(scores_res_new) = paste0("score",1:npc_select)#
}
scores_res_new
fpcs = fpca_res$har#
fpcs_varprp = fpca_res$varprp#
#
betas = scores_res%>%data.frame%>%select(matches("score"),y)%>%lm(y~.,data=.)%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])#
#
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
    beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}
fpcs = fpca_res$har#
fpcs_varprp = fpca_res$varprp#
#
betas = scores_res_train%>%data.frame%>%select(matches("score"),y)%>%lm(y~.,data=.)%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
    beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}
fitted_y =  inprod(beta_fd,train.fd) + beta0+meany
predicted_y =  inprod(beta_fd,test.fd) + beta0+meany
fitted_y
predicted_y
sfpca = function(xmat,y,theta,lambda,npc_select = 3,timepts=NULL,xmat_new=NULL)#
{#
#
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix =xmat;rowM = rowMeans(train_matrix);train_matrix =sweep(train_matrix,1,rowM)#
train_y = y; meany = mean(train_y);train_y = (train_y-meany)#
if (is.null(timepts)) timepts=1:nrow(xmat)#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=range(timepts),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd, 1e2)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
if(!is.null(xmat_new)) #
    {#
        test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
        test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
#
    }#
W = inprod(spline.basis,spline.basis)#
S = train.fd$coef #
maty = matrix(rep(train_y,each=nrow(S)),nrow=nrow(S))#
M = rowSums(maty*W%*%S)#
MM = as.matrix(M)%*%t(as.matrix(M))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}#
#
fpca = function(theta,lambda,npc)#
{#
#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
#
halfG_inv  = sqrM(G)#
#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
    })#
list(har = fd_list,varprp = varprp)#
}#
#
fpca_res = fpca(theta,lambda,npc=npc_select)#
## train scores#
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))#
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y#
## test scores#
#
fpcs = fpca_res$har#
fpcs_varprp = fpca_res$varprp#
#
betas = scores_res_train%>%data.frame%>%select(matches("score"),y)%>%lm(y~.,data=.)%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])#
#
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
    beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}#
#
intercept = beta0 + meany#
fitted_y =  inprod(beta_fd,train.fd) + intercept#
predicted_y = NULL#
if(!is.null(xmat_new)) {#
    predicted_y =  inprod(beta_fd,test.fd) + intercept#
}#
return(list(intercept =  intercept, beta_fd = beta_fd, fitted = fitted_y, pred = predicted_y, sfpcs=fpcs,sfpcs_varprp=fpcs_varprp,theta=theta,lambda=lambda))#
}
res = sfpca(xmat,y,0.1,1e3,npc_select=5,xmat_new = xmat[,1:10])
res
res$fitted
res$pred
sfpca = function(xmat,y,theta,lambda,npc_select = 3,timepts=NULL,xmat_new=NULL)#
{#
#
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix =xmat;rowM = rowMeans(train_matrix);train_matrix =sweep(train_matrix,1,rowM)#
train_y = y; meany = mean(train_y);train_y = (train_y-meany)#
if (is.null(timepts)) timepts=1:nrow(xmat)#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=range(timepts),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd, 1e2)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
if(!is.null(xmat_new)) #
    {#
        test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
        test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
#
    }#
W = inprod(spline.basis,spline.basis)#
S = train.fd$coef #
maty = matrix(rep(train_y,each=nrow(S)),nrow=nrow(S))#
M = rowSums(maty*W%*%S)#
MM = as.matrix(M)%*%t(as.matrix(M))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}#
#
fpca = function(theta,lambda,npc)#
{#
#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
#
halfG_inv  = sqrM(G)#
#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
    })#
list(har = fd_list,varprp = varprp)#
}#
#
fpca_res = fpca(theta,lambda,npc=npc_select)#
## train scores#
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))#
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y#
## test scores#
#
fpcs = fpca_res$har#
fpcs_varprp = fpca_res$varprp#
#
betas = scores_res_train%>%data.frame%>%select(matches("score"),y)%>%lm(y~.,data=.)%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])#
#
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
    beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}#
#
intercept = beta0 + meany#
fitted_y =  inprod(beta_fd,train.fd) + intercept#
predicted_y = NULL#
if(!is.null(xmat_new)) {#
    predicted_y =  inprod(beta_fd,test.fd) + intercept#
}#
return(list(intercept =  intercept, beta_fd = beta_fd, fitted = fitted_y, predicted = predicted_y, sfpcs=fpcs,sfpcs_varprp=fpcs_varprp,theta=theta,lambda=lambda))#
}
sfpca_con = function(xmat,y,theta,lambda,npc_select = 3,timepts=NULL,xmat_new=NULL)#
{#
stopifnot(length(unique(y))<=2) #
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix =xmat;rowM = rowMeans(train_matrix);train_matrix =sweep(train_matrix,1,rowM)#
train_y = y; meany = mean(train_y);train_y = (train_y-meany)#
if (is.null(timepts)) timepts=1:nrow(xmat)#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=range(timepts),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd, 1e2)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
if(!is.null(xmat_new)) #
	{#
		test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
		test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
#
	}#
W = inprod(spline.basis,spline.basis)#
S = train.fd$coef #
maty = matrix(rep(train_y,each=nrow(S)),nrow=nrow(S))#
M = rowSums(maty*W%*%S)#
MM = as.matrix(M)%*%t(as.matrix(M))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}#
#
fpca = function(theta,lambda,npc)#
{#
#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
#
halfG_inv  = sqrM(G)#
#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
	})#
list(har = fd_list,varprp = varprp)#
}#
#
fpca_res = fpca(theta,lambda,npc=npc_select)#
## train scores#
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))#
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y#
## test scores#
#
fpcs = fpca_res$har#
fpcs_varprp = fpca_res$varprp#
#
betas = scores_res_train%>%data.frame%>%select(matches("score"),y)%>%lm(y~.,data=.)%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])#
#
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
	beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}#
#
intercept = beta0 + meany#
fitted_y =  inprod(beta_fd,train.fd) + intercept#
predicted_y = NULL#
if(!is.null(xmat_new)) {#
	predicted_y =  inprod(beta_fd,test.fd) + intercept#
}#
return(list(intercept =  intercept, beta_fd = beta_fd, fitted = fitted_y, predicted = predicted_y, sfpcs=fpcs,sfpcs_varprp=fpcs_varprp,theta=theta,lambda=lambda))#
}
??stopifnot
sfpca_con = function(xmat,y,theta,lambda,npc_select = 3,timepts=NULL,xmat_new=NULL)#
{#
stopifnot(length(unique(y))<=2) #
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix =xmat;rowM = rowMeans(train_matrix);train_matrix =sweep(train_matrix,1,rowM)#
train_y = y; meany = mean(train_y);train_y = (train_y-meany)#
if (is.null(timepts)) timepts=1:nrow(xmat)#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=range(timepts),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd, 1e2)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
if(!is.null(xmat_new)) #
    {#
        test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
        test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
#
    }#
W = inprod(spline.basis,spline.basis)#
S = train.fd$coef #
maty = matrix(rep(train_y,each=nrow(S)),nrow=nrow(S))#
M = rowSums(maty*W%*%S)#
MM = as.matrix(M)%*%t(as.matrix(M))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}#
#
fpca = function(theta,lambda,npc)#
{#
#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
#
halfG_inv  = sqrM(G)#
#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
    })#
list(har = fd_list,varprp = varprp)#
}#
#
fpca_res = fpca(theta,lambda,npc=npc_select)#
## train scores#
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))#
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y#
## test scores#
#
fpcs = fpca_res$har#
fpcs_varprp = fpca_res$varprp#
#
betas = scores_res_train%>%data.frame%>%select(matches("score"),y)%>%lm(y~.,data=.)%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])#
#
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
    beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}#
#
intercept = beta0 + meany#
fitted_y =  inprod(beta_fd,train.fd) + intercept#
predicted_y = NULL#
if(!is.null(xmat_new)) {#
    predicted_y =  inprod(beta_fd,test.fd) + intercept#
}#
return(list(intercept =  intercept, beta_fd = beta_fd, fitted = fitted_y, predicted = predicted_y, sfpcs=fpcs,sfpcs_varprp=fpcs_varprp,theta=theta,lambda=lambda))#
}
res = sfpca(xmat,y,0.1,1e3,npc_select=5,xmat_new = xmat[,1:10])
res
sfpcs_binary = function(xmat,y,npc=1,theta= 0.5, lambda = 10,timepts=NULL,xmat_new = NULL)#
{#
stopifnot(length(unique(y))==2) #
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix = xmat;#
rowM = rowMeans(train_matrix);train_matrix = sweep(train_matrix,1,rowM)#
train_y = y#
#
if (is.null(timepts)) timepts=1:nrow(train_matrix);#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=c(1,nrow(train_matrix)),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd,1)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2)#
if(!is.null(xmat_new)) #
{#
 		test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
		test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
}#
W = inprod(spline.basis,spline.basis)#
### matrix S the coef matrix for the observed curves #
S = train.fd$coef #
M1 = W%*%S%*%as.matrix(train_y)#
M2 = W%*%S%*%(matrix(1,nrow=length(train_y),ncol=1)-as.matrix(train_y))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}#
#
fpca = function(theta,lambda,npc)#
{#
#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
halfG_inv  = sqrM(G)#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
	})#
list(har = fd_list,varprp = varprp)#
}#
#
fpca_res = fpca(theta,lambda,npc=npc_select)#
## train scores#
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))#
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y#
#
formula_pc = as.formula(paste0("y~",paste0(paste0("score",1:npc),collapse="+")))#
#
glm_fit = glm(formula_pc,scores_res_train,family="binomial")#
fitted = ifelse(predict(glm_fit,newdata=scores_res_train,type="link")>0,1,0)#
predicted_y  = NULL#
if(!is.null(xmat_new)) {#
	scores_res_test = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,test.fd))))#
	names(scores_res_test) = paste0("score",1:npc_select);#
	predicted_y = ifelse(predict(glm_fit,newdata=scores_res_test,type="link")>0,1,0)#
}#
fpcs = res$fpcs#
betas = glm_fit%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])#
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
    beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}#
return(list( intercept = beta0,  beta_fd=beta_fd,fitted=fitted,predicted = predicted_y, sfpcs=fpcs,theta=theta,lambda=lambda))#
}
data(binary_dat);xmat = binary_dat$x;y=binary_dat$y
res = sfpcs_binary(xmat,y,npc=2,theta=1,xmat_new = xmat)
xmat=xmat
y =
y
t
y
theta=1
xmat_new = xmat
lambda=10
timepts=NULL
stopifnot(length(unique(y))==2) #
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix = xmat;#
rowM = rowMeans(train_matrix);train_matrix = sweep(train_matrix,1,rowM)#
train_y = y#
#
if (is.null(timepts)) timepts=1:nrow(train_matrix);#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=c(1,nrow(train_matrix)),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd,1)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2)#
if(!is.null(xmat_new)) #
{#
 		test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
		test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
}
W = inprod(spline.basis,spline.basis)#
### matrix S the coef matrix for the observed curves #
S = train.fd$coef #
M1 = W%*%S%*%as.matrix(train_y)#
M2 = W%*%S%*%(matrix(1,nrow=length(train_y),ncol=1)-as.matrix(train_y))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}
theta
lambda
npc
npc = npc_select
npc
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)
theta/length(train_y)*W%*%S%*%t(S)%*%W
(1-theta)*MM/(length(train_y)^2)
dim(MM)
MM = as.matrix(M)%*%t(as.matrix(M))
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)
dim(MM)
M
sFPCA::sfpcs_binary
MM = M1 %*% t(M1)/sum(train_y) + M2 %*% t(M2)/(length(train_y) - #
            sum(train_y))
dim(MM)
fpca = function(theta,lambda,npc)#
{#
MM = M1 %*% t(M1)/sum(train_y) + M2 %*% t(M2)/(length(train_y) - #
            sum(train_y))#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
halfG_inv  = sqrM(G)#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
	})#
list(har = fd_list,varprp = varprp)#
}
fpca_res = fpca(theta,lambda,npc=npc_select)
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))#
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y#
#
formula_pc = as.formula(paste0("y~",paste0(paste0("score",1:npc),collapse="+")))#
#
glm_fit = glm(formula_pc,scores_res_train,family="binomial")#
fitted = ifelse(predict(glm_fit,newdata=scores_res_train,type="link")>0,1,0)
fitted
fitted==y
table(fitted==y)
predicted_y  = NULL#
if(!is.null(xmat_new)) {#
    scores_res_test = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,test.fd))))#
    names(scores_res_test) = paste0("score",1:npc_select);#
    predicted_y = ifelse(predict(glm_fit,newdata=scores_res_test,type="link")>0,1,0)#
}
sfpcs_binary = function(xmat,y,npc=1,theta= 0.5, lambda = 10,timepts=NULL,xmat_new = NULL)#
{#
#
stopifnot(length(unique(y))==2) #
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix = xmat;#
rowM = rowMeans(train_matrix);train_matrix = sweep(train_matrix,1,rowM)#
train_y = y#
#
if (is.null(timepts)) timepts=1:nrow(train_matrix);#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=c(1,nrow(train_matrix)),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd,1)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2)#
if(!is.null(xmat_new)) #
{#
        test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
        test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
}#
W = inprod(spline.basis,spline.basis)#
### matrix S the coef matrix for the observed curves #
S = train.fd$coef #
M1 = W%*%S%*%as.matrix(train_y)#
M2 = W%*%S%*%(matrix(1,nrow=length(train_y),ncol=1)-as.matrix(train_y))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}#
#
fpca = function(theta,lambda,npc)#
{#
MM = M1 %*% t(M1)/sum(train_y) + M2 %*% t(M2)/(length(train_y) - #
            sum(train_y))#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
halfG_inv  = sqrM(G)#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
    })#
list(har = fd_list,varprp = varprp)#
}#
#
fpca_res = fpca(theta,lambda,npc=npc_select)#
## train scores#
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))#
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y#
#
formula_pc = as.formula(paste0("y~",paste0(paste0("score",1:npc),collapse="+")))#
#
glm_fit = glm(formula_pc,scores_res_train,family="binomial")#
fitted = ifelse(predict(glm_fit,newdata=scores_res_train,type="link")>0,1,0)#
predicted_y  = NULL#
if(!is.null(xmat_new)) {#
    scores_res_test = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,test.fd))))#
    names(scores_res_test) = paste0("score",1:npc_select);#
    predicted_y = ifelse(predict(glm_fit,newdata=scores_res_test,type="link")>0,1,0)#
}#
fpcs = res$fpcs#
betas = glm_fit%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])#
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
    beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}#
return(list( intercept = beta0,  beta_fd=beta_fd,fitted=fitted,predicted = predicted_y, sfpcs=fpcs,theta=theta,lambda=lambda))#
}
res = sfpcs_binary(xmat,y,npc=2,theta=1,xmat_new = xmat)
res
sfpcs_binary = function(xmat,y,npc=1,theta= 0.5, lambda = 10,timepts=NULL,xmat_new = NULL)#
{#
#
stopifnot(length(unique(y))==2) #
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix = xmat;#
rowM = rowMeans(train_matrix);train_matrix = sweep(train_matrix,1,rowM)#
train_y = y#
#
if (is.null(timepts)) timepts=1:nrow(train_matrix);#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=c(1,nrow(train_matrix)),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd,1)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2)#
if(!is.null(xmat_new)) #
{#
 		test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
		test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
}#
W = inprod(spline.basis,spline.basis)#
### matrix S the coef matrix for the observed curves #
S = train.fd$coef #
M1 = W%*%S%*%as.matrix(train_y)#
M2 = W%*%S%*%(matrix(1,nrow=length(train_y),ncol=1)-as.matrix(train_y))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}#
#
fpca = function(theta,lambda,npc)#
{#
MM = M1 %*% t(M1)/sum(train_y) + M2 %*% t(M2)/(length(train_y) - #
            sum(train_y))#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
halfG_inv  = sqrM(G)#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
	})#
list(har = fd_list,varprp = varprp)#
}#
#
fpca_res = fpca(theta,lambda,npc=npc_select)#
## train scores#
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))#
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y#
#
formula_pc = as.formula(paste0("y~",paste0(paste0("score",1:npc),collapse="+")))#
#
glm_fit = glm(formula_pc,scores_res_train,family="binomial")#
fitted = ifelse(predict(glm_fit,newdata=scores_res_train,type="link")>0,1,0)#
predicted_y  = NULL#
if(!is.null(xmat_new)) {#
	scores_res_test = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,test.fd))))#
	names(scores_res_test) = paste0("score",1:npc_select);#
	predicted_y = ifelse(predict(glm_fit,newdata=scores_res_test,type="link")>0,1,0)#
}#
fpcs = res$har#
betas = glm_fit%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])#
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
    beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}#
return(list( intercept = beta0,  beta_fd=beta_fd,fitted=fitted,predicted = predicted_y, sfpcs=fpcs,theta=theta,lambda=lambda))#
}
res = sfpcs_binary(xmat,y,npc=2,theta=1,xmat_new = xmat)
sfpcs_binary = function(xmat,y,npc_select=2,theta= 0.5, lambda = 10,timepts=NULL,xmat_new = NULL)#
{#
#
stopifnot(length(unique(y))==2) #
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix = xmat;#
rowM = rowMeans(train_matrix);train_matrix = sweep(train_matrix,1,rowM)#
train_y = y#
#
if (is.null(timepts)) timepts=1:nrow(train_matrix);#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=c(1,nrow(train_matrix)),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd,1)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2)#
if(!is.null(xmat_new)) #
{#
        test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
        test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
}#
W = inprod(spline.basis,spline.basis)#
### matrix S the coef matrix for the observed curves #
S = train.fd$coef #
M1 = W%*%S%*%as.matrix(train_y)#
M2 = W%*%S%*%(matrix(1,nrow=length(train_y),ncol=1)-as.matrix(train_y))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}#
#
fpca = function(theta,lambda,npc)#
{#
MM = M1 %*% t(M1)/sum(train_y) + M2 %*% t(M2)/(length(train_y) - #
            sum(train_y))#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
halfG_inv  = sqrM(G)#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
    })#
list(har = fd_list,varprp = varprp)#
}#
#
fpca_res = fpca(theta,lambda,npc=npc_select)#
## train scores#
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))#
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y#
#
formula_pc = as.formula(paste0("y~",paste0(paste0("score",1:npc),collapse="+")))#
#
glm_fit = glm(formula_pc,scores_res_train,family="binomial")#
fitted = ifelse(predict(glm_fit,newdata=scores_res_train,type="link")>0,1,0)#
predicted_y  = NULL#
if(!is.null(xmat_new)) {#
    scores_res_test = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,test.fd))))#
    names(scores_res_test) = paste0("score",1:npc_select);#
    predicted_y = ifelse(predict(glm_fit,newdata=scores_res_test,type="link")>0,1,0)#
}#
fpcs = res$har#
betas = glm_fit%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])#
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
    beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}#
return(list( intercept = beta0,  beta_fd=beta_fd,fitted=fitted,predicted = predicted_y, sfpcs=fpcs,theta=theta,lambda=lambda))#
}
res = sfpcs_binary(xmat,y,npc_select=2,theta=1,xmat_new = xmat)
npc_select
sfpcs_binary = function(xmat,y,npc_select=2,theta= 0.5, lambda = 10,timepts=NULL,xmat_new = NULL)#
{#
#
stopifnot(length(unique(y))==2) #
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix = xmat;#
rowM = rowMeans(train_matrix);train_matrix = sweep(train_matrix,1,rowM)#
train_y = y#
#
if (is.null(timepts)) timepts=1:nrow(train_matrix);#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=c(1,nrow(train_matrix)),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd,1)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2)#
if(!is.null(xmat_new)) #
{#
        test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
        test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
}#
W = inprod(spline.basis,spline.basis)#
### matrix S the coef matrix for the observed curves #
S = train.fd$coef #
M1 = W%*%S%*%as.matrix(train_y)#
M2 = W%*%S%*%(matrix(1,nrow=length(train_y),ncol=1)-as.matrix(train_y))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}#
#
fpca = function(theta,lambda,npc)#
{#
MM = M1 %*% t(M1)/sum(train_y) + M2 %*% t(M2)/(length(train_y) - #
            sum(train_y))#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
halfG_inv  = sqrM(G)#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
    })#
list(har = fd_list,varprp = varprp)#
}#
#
fpca_res = fpca(theta,lambda,npc=npc_select)#
## train scores#
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))#
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y#
#
formula_pc = as.formula(paste0("y~",paste0(paste0("score",1:npc_select),collapse="+")))#
#
glm_fit = glm(formula_pc,scores_res_train,family="binomial")#
fitted = ifelse(predict(glm_fit,newdata=scores_res_train,type="link")>0,1,0)#
predicted_y  = NULL#
if(!is.null(xmat_new)) {#
    scores_res_test = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,test.fd))))#
    names(scores_res_test) = paste0("score",1:npc_select);#
    predicted_y = ifelse(predict(glm_fit,newdata=scores_res_test,type="link")>0,1,0)#
}#
fpcs = res$har#
betas = glm_fit%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])#
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
    beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}#
return(list( intercept = beta0,  beta_fd=beta_fd,fitted=fitted,predicted = predicted_y, sfpcs=fpcs,theta=theta,lambda=lambda))#
}
res = sfpcs_binary(xmat,y,npc_select=2,theta=1,xmat_new = xmat)
res
res$intercept
res$beta_fd
plot(res$beta_fd)
sfpcs_binary = function(xmat,y,npc_select=2,theta= 0.5, lambda = 10,timepts=NULL,xmat_new = NULL)#
{#
#
stopifnot(length(unique(y))==2) #
stopifnot(all(c("fda","dplyr")%in%rownames(installed.packages()))) #
train_matrix = xmat;#
rowM = rowMeans(train_matrix);train_matrix = sweep(train_matrix,1,rowM)#
train_y = y#
#
if (is.null(timepts)) timepts=1:nrow(train_matrix);#
norder=4 ## cubic B-spline#
nbasis=norder+length(timepts)-2; (nbasis)#
spline.basis=create.bspline.basis(rangeval=c(1,nrow(train_matrix)),nbasis,norder,timepts)#
D2Lfd <- int2Lfd(m=2)#
D2fdPar     <- fdPar(spline.basis, D2Lfd,1)#
train.fd <- Data2fd(y=train_matrix, argvals=timepts,D2fdPar,nderiv=2)#
if(!is.null(xmat_new)) #
{#
        test_matrix = xmat_new;test_matrix =sweep(test_matrix,1,rowM)#
        test.fd <- Data2fd(y=test_matrix, argvals=timepts,D2fdPar,nderiv=2,lambda=1e2)#
}#
W = inprod(spline.basis,spline.basis)#
### matrix S the coef matrix for the observed curves #
S = train.fd$coef #
M1 = W%*%S%*%as.matrix(train_y)#
M2 = W%*%S%*%(matrix(1,nrow=length(train_y),ncol=1)-as.matrix(train_y))#
sqrM = function (X) #
{#
    EX <- eigen(X)#
    VX <- EX$values#
    QX <- EX$vectors#
    YX <- QX %*% diag(1/sqrt(VX)) %*% t(QX)#
    return(YX)#
}#
#
fpca = function(theta,lambda,npc)#
{#
MM = M1 %*% t(M1)/sum(train_y) + M2 %*% t(M2)/(length(train_y) - #
            sum(train_y))#
Q =theta/length(train_y)*W%*%S%*%t(S)%*%W+(1-theta)*MM/(length(train_y)^2)#
D = inprod(spline.basis,spline.basis,Lfdobj1=2,Lfdobj2=2)#
G = W + lambda*D#
halfG_inv  = sqrM(G)#
tM = t(halfG_inv)%*%Q%*%halfG_inv#
eigen_res = eigen(tM)#
varprp  = round(head(eigen_res$values/sum(eigen_res$values),npc)*100,4)#
fd_list = lapply(1:npc,function(ipc)#
{#
cat(ipc)#
coef_pc= halfG_inv%*%as.matrix(eigen_res$vectors[,ipc])#
fd= fd(coef=coef_pc,spline.basis)#
fd#
    })#
list(har = fd_list,varprp = varprp)#
}#
#
fpca_res = fpca(theta,lambda,npc=npc_select)#
## train scores#
scores_res_train = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,train.fd))))#
names(scores_res_train) = paste0("score",1:npc_select);scores_res_train$theta=theta;scores_res_train$lambda=lambda;scores_res_train$y=train_y#
#
formula_pc = as.formula(paste0("y~",paste0(paste0("score",1:npc_select),collapse="+")))#
#
glm_fit = glm(formula_pc,scores_res_train,family="binomial")#
fitted = ifelse(predict(glm_fit,newdata=scores_res_train,type="link")>0,1,0)#
predicted_y  = NULL#
if(!is.null(xmat_new)) {#
    scores_res_test = do.call(cbind.data.frame,lapply(fpca_res$har,function(x) as.numeric(inprod(x,test.fd))))#
    names(scores_res_test) = paste0("score",1:npc_select);#
    predicted_y = ifelse(predict(glm_fit,newdata=scores_res_test,type="link")>0,1,0)#
}#
fpcs = fpca_res$har#
betas = glm_fit%>%coef#
beta0 = as.vector(betas[1])#
beta_func = as.vector(betas[-1])#
beta_fd = beta_func[1]*fpcs[[1]]#
for (i in 2:length(beta_func))#
{#
    beta_fd  = beta_fd + beta_func[i]*fpcs[[i]]#
}#
return(list( intercept = beta0,  beta_fd=beta_fd,fitted=fitted,predicted = predicted_y, sfpcs=fpcs,theta=theta,lambda=lambda))#
}
res = sfpcs_binary(xmat,y,npc_select=2,theta=1,xmat_new = xmat)
res
res$fitted
res$predicted
res$predicted == res$fitted
table(res$predicted == res$fitted)
str(res)
names(res)
dim(xmat)
git_push(git_dir="~/Dropbox/Rpackages/")
git_push(git_dir="~/Dropbox/Rpackages/sFPCA/")
git_push(git_dir="~/Dropbox/Rpackages/sFPCA/")
git_push(git_dir="~/Dropbox/Rpackages/",comment="add prediction set")
git_push(git_dir="~/Dropbox/Rpackages/",comment="add prediction set",commit=TRUE)
git_push(git_dir="~/Dropbox/Rpackages/sFPCA/",comment="add prediction set",commit=TRUE)
install_github("YunlongNie/sFPCA")
devtools::install_github("YunlongNie/sFPCA")
git_push(git_dir="~/Dropbox/Rpackages/sFPCA/",comment="add prediction set",commit=TRUE)
git_push(git_dir="~/Dropbox/Rpackages/sFPCA/",comment="add prediction set",commit=TRUE)
devtools::install_github("YunlongNie/sFPCA")
name_package = "sFPCA"#
title_package = "R package for supervised FPCA"#
build_dir = '/Users/joha/Dropbox/Rpackages/'#
code_dir = "sfpca_source/Rcode_pk"#
(R_code = list.files(file.path(build_dir,code_dir), pattern=".R",full.names=TRUE))#
(package_dir = file.path(build_dir,name_package))#
#
library("devtools")#
library("roxygen2")#
library(dplyr)#
#
install_github('YunlongNie/makingRpk',force=TRUE)#
library(makingRpk)
DESCRIPTION_make(name_package=name_package,build_dir= build_dir,title_package=title_package,version="1.0")
roxygenise(package.dir=package_dir)
git_push(git_dir="~/Dropbox/Rpackages/sFPCA/",comment="add prediction set",commit=TRUE)
devtools::install_github("YunlongNie/sFPCA")
